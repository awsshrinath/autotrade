import datetime
import json
import os

from runner.risk_governor import RiskGovernor
from runner.cognitive_system import CognitiveSystem, create_cognitive_system
from runner.thought_journal import DecisionType, ConfidenceLevel
from runner.cognitive_state_machine import CognitiveState, StateTransitionTrigger
from runner.metacognition import DecisionOutcome

# âœ… Initialize with limits
risk_guard = RiskGovernor(max_daily_loss=500, max_trades=3, cutoff_time="15:00")


class TradeManager:
    def __init__(self, logger=None, kite=None, firestore_client=None, cognitive_system=None):
        self.logger = logger
        self.kite = kite
        self.firestore_client = firestore_client
        self.open_positions = []
        self.strategy_map = {}
        
        # Initialize cognitive system
        self.cognitive_system = cognitive_system
        if self.cognitive_system is None:
            try:
                self.cognitive_system = create_cognitive_system(logger=self.logger)
                if self.logger:
                    self.logger.log_event("Cognitive system initialized for TradeManager")
            except Exception as e:
                if self.logger:
                    self.logger.log_event(f"Failed to initialize cognitive system: {e}")
                self.cognitive_system = None

    def run_strategy_once(self, strategy_name, direction, bot_type):
        """
        Run a strategy once and execute a trade if a signal is generated.

        Args:
            strategy_name (str): The name of the strategy to run
            direction (str): The direction of the trade (bullish or bearish)
            bot_type (str): The type of bot (stock, options, futures)

        Returns:
            dict: The executed trade or None if no trade was executed
        """
        # Record cognitive thought about strategy selection
        if self.cognitive_system:
            self.cognitive_system.record_thought(
                decision=f"Running {strategy_name} strategy for {bot_type}",
                reasoning=f"Selected {strategy_name} strategy with {direction} direction for {bot_type} bot",
                decision_type=DecisionType.STRATEGY_SELECTION,
                confidence=ConfidenceLevel.MEDIUM,
                market_context={
                    'strategy': strategy_name,
                    'direction': direction,
                    'bot_type': bot_type
                },
                tags=['strategy_execution', strategy_name, bot_type]
            )
            
            # Transition to analyzing state
            self.cognitive_system.transition_state(
                CognitiveState.ANALYZING,
                StateTransitionTrigger.SIGNAL_DETECTED,
                f"Analyzing {strategy_name} for {bot_type}"
            )

        if strategy_name not in self.strategy_map:
            if self.logger:
                self.logger.log_event(
                    f"[ERROR] Strategy {strategy_name} not found in strategy map"
                )
            
            # Record cognitive thought about error
            if self.cognitive_system:
                self.cognitive_system.record_thought(
                    decision=f"Strategy {strategy_name} not found",
                    reasoning="Strategy mapping error detected",
                    decision_type=DecisionType.MARKET_ANALYSIS,
                    confidence=ConfidenceLevel.VERY_HIGH,
                    tags=['error', 'strategy_mapping']
                )
            
            return None

        # Get the strategy function
        strategy_func = self.strategy_map[strategy_name]

        # Run the strategy to get a trade signal
        trade_signal = strategy_func(symbol=bot_type, direction=direction)

        if not trade_signal:
            if self.logger:
                self.logger.log_event(
                    f"[INFO] No trade signal generated by {strategy_name}"
                )
            
            # Record cognitive thought about no signal
            if self.cognitive_system:
                self.cognitive_system.record_thought(
                    decision="No trade signal generated",
                    reasoning=f"{strategy_name} did not produce actionable signal for {direction} {bot_type}",
                    decision_type=DecisionType.MARKET_ANALYSIS,
                    confidence=ConfidenceLevel.MEDIUM,
                    market_context={
                        'strategy': strategy_name,
                        'direction': direction,
                        'bot_type': bot_type,
                        'signal_result': 'no_signal'
                    },
                    tags=['no_signal', strategy_name]
                )
                
                # Transition back to observing
                self.cognitive_system.transition_state(
                    CognitiveState.OBSERVING,
                    StateTransitionTrigger.NEW_DATA_AVAILABLE,
                    "No signal generated, resuming observation"
                )
            
            return None

        # Execute the trade
        trade = self._execute_trade(trade_signal, bot_type, strategy_name)

        # Track the open position
        if trade:
            self.open_positions.append(trade)

        return trade

    def _execute_trade(self, trade_signal, bot_type, strategy_name=None):
        """
        Execute a trade based on a trade signal.

        Args:
            trade_signal (dict): The trade signal
            bot_type (str): The type of bot (stock, options, futures)
            strategy_name (str): The name of the strategy used

        Returns:
            dict: The executed trade or None if the trade was not executed
        """
        # Calculate confidence based on signal strength
        signal_strength = trade_signal.get('confidence', 0.5)
        confidence_level = self._map_signal_to_confidence(signal_strength)
        
        # Record cognitive thought about trade decision
        if self.cognitive_system:
            thought_id = self.cognitive_system.record_thought(
                decision=f"Executing trade for {trade_signal.get('symbol', 'UNKNOWN')}",
                reasoning=f"Signal strength: {signal_strength:.2f}, Entry: {trade_signal.get('entry_price')}, "
                          f"Direction: {trade_signal.get('direction')}, Strategy: {strategy_name}",
                decision_type=DecisionType.TRADE_ENTRY,
                confidence=confidence_level,
                market_context={
                    'symbol': trade_signal.get('symbol'),
                    'entry_price': trade_signal.get('entry_price'),
                    'direction': trade_signal.get('direction'),
                    'strategy': strategy_name,
                    'bot_type': bot_type,
                    'signal_strength': signal_strength
                },
                strategy_id=strategy_name,
                tags=['trade_execution', bot_type, strategy_name or 'unknown']
            )
        
        if not risk_guard.can_trade():
            if self.logger:
                self.logger.log_event(
                    f"ðŸš« Trade blocked by RiskGovernor: {trade_signal['symbol']}"
                )
            
            # Record cognitive thought about blocked trade
            if self.cognitive_system:
                self.cognitive_system.record_thought(
                    decision="Trade blocked by risk management",
                    reasoning="RiskGovernor prevented trade execution due to risk limits",
                    decision_type=DecisionType.RISK_ASSESSMENT,
                    confidence=ConfidenceLevel.VERY_HIGH,
                    market_context={
                        'blocked_symbol': trade_signal.get('symbol'),
                        'reason': 'risk_governor_block'
                    },
                    tags=['risk_management', 'trade_blocked']
                )
            
            return None

        # Transition to executing state
        if self.cognitive_system:
            self.cognitive_system.transition_state(
                CognitiveState.EXECUTING,
                StateTransitionTrigger.SIGNAL_DETECTED,
                f"Executing trade for {trade_signal.get('symbol')}"
            )

        # Create the trade object
        trade = {
            **trade_signal,
            "timestamp": datetime.datetime.now().isoformat(),
            "mode": "paper",  # Default to paper trading
            "status": "open",
            "bot_type": bot_type,
            "cognitive_thought_id": thought_id if self.cognitive_system else None,
            "confidence_level": confidence_level.value if self.cognitive_system else None
        }

        # Log the trade
        if self.firestore_client:
            try:
                date_str = datetime.datetime.now().strftime("%Y-%m-%d")
                self.firestore_client.log_trade(bot_type, date_str, trade)
            except Exception as e:
                if self.logger:
                    self.logger.log_event(f"Failed to log trade to Firestore: {e}")

        if self.logger:
            self.logger.log_event(
                f"[EXECUTE-{trade['mode'].upper()}] {trade.get('strategy', 'UNKNOWN')} trade executed for {trade['symbol']}"
            )
            self.logger.log_event(
                f"Qty: {trade['quantity']} | Entry: {trade['entry_price']} | SL: {trade['stop_loss']} | Target: {trade['target']}"
            )

        # Update the risk governor
        risk_guard.update_trade(0)  # Initial placeholder for PnL

        # Store trade details in cognitive memory
        if self.cognitive_system:
            trade_memory = f"Executed {trade.get('direction')} trade for {trade['symbol']} at {trade['entry_price']}"
            self.cognitive_system.store_memory(
                content=trade_memory,
                importance=self.cognitive_system.memory.ImportanceLevel.HIGH,
                tags=['trade_execution', trade['symbol'], bot_type],
                metadata={
                    'trade_id': trade.get('id'),
                    'entry_price': trade['entry_price'],
                    'strategy': strategy_name,
                    'timestamp': trade['timestamp']
                }
            )

        return trade

    def _map_signal_to_confidence(self, signal_strength):
        """Map signal strength (0-1) to ConfidenceLevel enum"""
        if signal_strength >= 0.8:
            return ConfidenceLevel.VERY_HIGH
        elif signal_strength >= 0.65:
            return ConfidenceLevel.HIGH
        elif signal_strength >= 0.4:
            return ConfidenceLevel.MEDIUM
        elif signal_strength >= 0.2:
            return ConfidenceLevel.LOW
        else:
            return ConfidenceLevel.VERY_LOW

    def analyze_trade_outcome(self, trade):
        """Analyze trade outcome using cognitive system"""
        if not self.cognitive_system or not trade:
            return
        
        try:
            # Determine outcome
            if trade.get('status') == 'target_hit':
                outcome = DecisionOutcome.SUCCESS
            elif trade.get('status') == 'stop_loss_hit':
                outcome = DecisionOutcome.FAILURE
            elif trade.get('pnl', 0) > 0:
                outcome = DecisionOutcome.PARTIAL_SUCCESS
            else:
                outcome = DecisionOutcome.FAILURE
            
            # Get initial confidence from trade
            confidence_level = trade.get('confidence_level', 3)
            initial_confidence = confidence_level / 5.0  # Convert to 0-1 scale
            
            # Calculate time to outcome
            if trade.get('hold_duration'):
                duration_str = trade['hold_duration']
                if 'mins' in duration_str:
                    time_to_outcome = float(duration_str.split()[0])
                else:
                    time_to_outcome = 0.0
            else:
                time_to_outcome = 0.0
            
            # Analyze the decision
            analysis_id = self.cognitive_system.analyze_decision(
                decision_id=trade.get('cognitive_thought_id', 'unknown'),
                decision_type='trade_entry',
                initial_confidence=initial_confidence,
                actual_outcome=outcome,
                profit_loss=trade.get('pnl', 0),
                strategy_used=trade.get('strategy', 'unknown'),
                market_context={
                    'symbol': trade.get('symbol'),
                    'entry_price': trade.get('entry_price'),
                    'exit_price': trade.get('exit_price'),
                    'direction': trade.get('direction'),
                    'bot_type': trade.get('bot_type')
                },
                time_to_outcome=time_to_outcome
            )
            
            # Record reflection thought
            self.cognitive_system.record_thought(
                decision=f"Trade completed for {trade.get('symbol')}",
                reasoning=f"Trade outcome: {outcome.value}, PnL: {trade.get('pnl', 0)}, "
                          f"Duration: {trade.get('hold_duration', 'unknown')}",
                decision_type=DecisionType.PERFORMANCE_REVIEW,
                confidence=ConfidenceLevel.HIGH,
                market_context=trade,
                trade_id=str(trade.get('id', 'unknown')),
                tags=['trade_completion', 'performance_review', trade.get('symbol', 'unknown')]
            )
            
            # Transition to reflection state
            self.cognitive_system.transition_state(
                CognitiveState.REFLECTING,
                StateTransitionTrigger.TRADE_COMPLETED,
                f"Analyzing outcome of {trade.get('symbol')} trade"
            )
            
        except Exception as e:
            if self.logger:
                self.logger.log_event(f"Failed to analyze trade outcome: {e}")


def execute_trade(trade, paper_mode=True):
    if not risk_guard.can_trade():
        print(f"ðŸš« Trade blocked by RiskGovernor: {trade['symbol']}")
        return

    now = datetime.datetime.now().isoformat()
    trade["timestamp"] = now
    trade["mode"] = "paper" if paper_mode else "real"
    trade["status"] = "open"

    log_path = f"logs/trade_log_{trade['strategy'].lower()}.jsonl"
    os.makedirs("logs", exist_ok=True)
    with open(log_path, "a") as f:
        f.write(json.dumps(trade) + "\n")

    print(
        f"[EXECUTE-{trade['mode'].upper()}] {trade['strategy']} trade executed for {trade['symbol']}"
    )
    print(
        f"Qty: {trade['quantity']} | Entry: {trade['entry_price']} | SL: {trade['stop_loss']} | Target: {trade['target']}"
    )

    risk_guard.update_trade(0)  # Initial placeholder for PnL


def simulate_exit(trade, candles):
    try:
        # âœ… Guard against incomplete trades
        required_keys = [
            "entry_price",
            "stop_loss",
            "target",
            "direction",
            "quantity",
            "strategy",
            "symbol",
        ]
        for key in required_keys:
            if key not in trade:
                print(
                    f"[WARN] Skipping exit simulation. Missing '{key}' in trade: {trade}"
                )
                return

        if trade["quantity"] <= 0:
            print(
                f"[WARN] Skipping exit simulation for {trade['symbol']}: quantity is 0"
            )
            return

        if not candles or not isinstance(candles, list):
            print(f"[WARN] No candles provided for simulate_exit on {trade['symbol']}")
            return

        entry = trade["entry_price"]
        sl = trade["stop_loss"]
        target = trade["target"]
        direction = trade["direction"]
        qty = trade["quantity"]
        status = "open"
        exit_price = entry
        hold_minutes = 0

        for candle in candles:
            hold_minutes += 5
            high = candle.get("high")
            low = candle.get("low")

            if high is None or low is None:
                continue

            if direction == "bullish":
                if high >= target:
                    status = "target_hit"
                    exit_price = target
                    break
                elif low <= sl:
                    status = "stop_loss_hit"
                    exit_price = sl
                    break
            else:
                if low <= target:
                    status = "target_hit"
                    exit_price = target
                    break
                elif high >= sl:
                    status = "stop_loss_hit"
                    exit_price = sl
                    break
        else:
            status = "auto_exit"
            exit_price = candles[-1].get("close", entry)

        # âœ… Update trade details safely
        trade["status"] = status
        trade["exit_price"] = exit_price
        trade["exit_time"] = candles[-1].get(
            "date", datetime.datetime.now().isoformat()
        )
        trade["hold_duration"] = f"{hold_minutes} mins"
        trade["pnl"] = round(
            (
                (exit_price - entry) * qty
                if direction == "bullish"
                else (entry - exit_price) * qty
            ),
            2,
        )

        # âœ… Log updated trade
        log_path = f"logs/trade_log_{trade['strategy'].lower()}.jsonl"
        with open(log_path, "a") as f:
            f.write(json.dumps(trade) + "\n")

        # âœ… Update RiskGovernor PnL
        risk_guard.update_trade(trade["pnl"])

        print(
            f"[EXIT-{trade['mode'].upper()}] {trade['symbol']} - {status.upper()} at {exit_price} | PnL: {trade['pnl']} | Held: {trade['hold_duration']}"
        )

        # Analyze trade outcome with cognitive system if available
        # Note: This requires a TradeManager instance to be available
        # In a real implementation, this would be called from the TradeManager instance

    except Exception as e:
        print(f"[ERROR] Simulate exit failed for {trade.get('symbol', 'UNKNOWN')}: {e}")
