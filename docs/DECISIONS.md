# Tron Trading System: Architectural Decision Records (ADR)

**Last Updated:** 2024-07-16

This document records the architectural decisions made for the Tron Trading System.

---

### ADR Template

When making a new architectural decision, please use the template below and add it to the top of the records list.

```markdown
---
### ADR-XXX: [Title of Decision]

-   **Date:** YYYY-MM-DD
-   **Status:** Proposed | Accepted | Deprecated | Superseded

#### Context

[Describe the issue, context, and problem that this decision addresses. What is the force field? What are the constraints?]

#### Decision

[Describe the decision that was made. What is the proposed solution?]

#### Consequences

[What are the positive and negative consequences of this decision? What is the impact on the system, developers, and users? What are the trade-offs?]

#### Alternatives Considered

[List other options that were considered and why they were not chosen.]
---
```

---

### Decision Records

---
### ADR-003: Adopt a Dual-Destination Enhanced Logging System

-   **Date:** 2024-07-16
-   **Status:** Accepted

#### Context

The initial logging system was inconsistent across pods and lacked structure. Debugging distributed issues in GKE was difficult, and there was no separation between real-time alerts and long-term analytics. We needed a unified system that could provide both immediate insights for dashboards and a cost-effective way to store verbose logs for later analysis.

#### Decision

We will implement an `enhanced_logging` module with a dual-destination strategy:
1.  **Google Firestore:** For high-priority, structured logs that need to be queried in real-time by the dashboard or alerting systems.
2.  **Google Cloud Storage (GCS):** For verbose, archival logs from all pods. These are cheaper to store and can be used for batch processing or deep analysis.
All log records will be in a structured JSON format, containing consistent metadata fields like `bot_type`, `category`, `log_level`, etc.

#### Consequences

-   **Positive:**
    -   Greatly improved observability and debugging capabilities.
    -   The dashboard can be powered by fast, real-time queries against Firestore.
    -   Reduces Firestore costs by offloading bulky, non-critical logs to GCS.
    -   Enforces a consistent logging standard across all current and future services.
-   **Negative:**
    -   Slightly increases the complexity of the logging client code.
    -   Requires managing two separate GCP services for logs.

#### Alternatives Considered

-   **Log only to GCS:** This would make real-time dashboarding slow and expensive, as it would require querying large text files.
-   **Log only to Firestore:** This would be very expensive due to the high volume of logs generated by the trading pods.
-   **Use a third-party logging service (e.g., Datadog, Logz.io):** This would add another vendor and associated cost to the stack. The GCP-native solution was preferred for better integration and potentially lower cost at our current scale.

---
### ADR-002: Use Kubernetes for Service Orchestration

-   **Date:** 2024-07-10
-   **Status:** Accepted

#### Context

The trading system consists of multiple independent processes (traders, orchestrator, dashboard). Running these manually or with simple scripts is not scalable, reliable, or suitable for a production environment. We needed a robust way to manage deployment, scaling, and resilience.

#### Decision

We will use Google Kubernetes Engine (GKE) to deploy and manage all components of the trading system. Each component will be containerized using Docker, and its deployment will be defined by a Kubernetes manifest (`.yaml` file).

#### Consequences

-   **Positive:**
    -   High availability and self-healing (pods restart automatically on failure).
    -   Declarative, version-controlled infrastructure (`.yaml` files).
    -   Scalability through Horizontal Pod Autoscaling (HPA).
    -   Simplified secrets and configuration management.
-   **Negative:**
    -   Adds a layer of complexity; developers need `kubectl` and GKE knowledge.
    -   Initial setup of the GKE cluster and deployment files requires effort.

#### Alternatives Considered

-   **Docker Compose:** Good for local development but not suitable for production resilience or scaling.
-   **Serverless (Cloud Functions/Run):** Could work for some components, but the long-running nature of the trading bots and the need for persistent connections make it a less natural fit than Kubernetes.

---
### ADR-001: Adopt a Microservices-based Pod Architecture

-   **Date:** 2024-07-08
-   **Status:** Accepted

#### Context

A monolithic trading application would be difficult to develop, deploy, and maintain. Different asset classes (stocks, options, futures) have different logic, and a failure in one part could bring down the entire system.

#### Decision

We will adopt a microservices-style architecture. The core logic for each trading asset class (stocks, options, futures) will be isolated in its own dedicated Kubernetes pod. A central `main-runner` pod will act as an orchestrator.

#### Consequences

-   **Positive:**
    -   Services can be developed, deployed, and scaled independently.
    -   Improved fault isolation: a crash in the `options-trader` will not affect the `stock-trader`.
    -   Clear separation of concerns.
-   **Negative:**
    -   Increases complexity, as we now have a distributed system.
    -   Requires inter-service communication mechanisms (we chose Firestore as an event bus).

#### Alternatives Considered

-   **Monolithic Application:** A single application containing all trading logic. This was rejected due to lack of fault isolation and scalability.
-   **Multi-threaded Application:** Running each strategy in a separate thread within a single process. This is simpler but still suffers from a lack of fault isolation compared to separate processes/pods. 